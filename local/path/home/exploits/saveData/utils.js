// servers/home/exploits/saveData/utils.ts
var SaveDataError = class extends Error {
  constructor(message) {
    super(message);
    this.name = this.constructor.name;
  }
};
var UnsupportedSaveData = class extends SaveDataError {
};
var InvalidSaveData = class extends SaveDataError {
};
function canUseBinaryFormat() {
  return "CompressionStream" in globalThis;
}
async function compress(dataString) {
  const compressedReadableStream = new Blob([dataString]).stream().pipeThrough(new globalThis.CompressionStream("gzip"));
  return new Uint8Array(await new Response(compressedReadableStream).arrayBuffer());
}
async function decompress(binaryData) {
  const decompressedReadableStream = new Blob([binaryData]).stream().pipeThrough(new globalThis.DecompressionStream("gzip"));
  const reader = decompressedReadableStream.pipeThrough(new TextDecoderStream("utf-8", { fatal: true })).getReader();
  let result = "";
  try {
    for (let { value, done } = await reader.read(); !done; { value, done } = await reader.read()) {
      result += value;
    }
  } catch (error) {
    throw new InvalidSaveData(String(error));
  }
  return result;
}
async function encodeJsonSaveString(jsonSaveString) {
  if (canUseBinaryFormat()) {
    return await compress(jsonSaveString);
  } else {
    return btoa(unescape(encodeURIComponent(jsonSaveString)));
  }
}
async function decodeSaveData(saveData) {
  if (saveData instanceof Uint8Array) {
    if (!canUseBinaryFormat()) {
      throw new UnsupportedSaveData("Your browser does not support Compression Streams API");
    }
    return await decompress(saveData);
  } else {
    return decodeURIComponent(escape(atob(saveData)));
  }
}
export {
  InvalidSaveData,
  SaveDataError,
  UnsupportedSaveData,
  canUseBinaryFormat,
  decodeSaveData,
  encodeJsonSaveString
};
