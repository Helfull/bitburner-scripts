// servers/home/exploits/saveData/utils.ts
var SaveDataError = class extends Error {
  constructor(message) {
    super(message);
    this.name = this.constructor.name;
  }
};
var UnsupportedSaveData = class extends SaveDataError {
};
var InvalidSaveData = class extends SaveDataError {
};
function canUseBinaryFormat() {
  return "CompressionStream" in globalThis;
}
async function compress(dataString) {
  const compressedReadableStream = new Blob([dataString]).stream().pipeThrough(new globalThis.CompressionStream("gzip"));
  return new Uint8Array(await new Response(compressedReadableStream).arrayBuffer());
}
async function decompress(binaryData) {
  const decompressedReadableStream = new Blob([binaryData]).stream().pipeThrough(new globalThis.DecompressionStream("gzip"));
  const reader = decompressedReadableStream.pipeThrough(new TextDecoderStream("utf-8", { fatal: true })).getReader();
  let result = "";
  try {
    for (let { value, done } = await reader.read(); !done; { value, done } = await reader.read()) {
      result += value;
    }
  } catch (error) {
    throw new InvalidSaveData(String(error));
  }
  return result;
}
async function encodeJsonSaveString(jsonSaveString) {
  if (canUseBinaryFormat()) {
    return await compress(jsonSaveString);
  } else {
    return btoa(unescape(encodeURIComponent(jsonSaveString)));
  }
}
async function decodeSaveData(saveData) {
  if (saveData instanceof Uint8Array) {
    if (!canUseBinaryFormat()) {
      throw new UnsupportedSaveData("Your browser does not support Compression Streams API");
    }
    return await decompress(saveData);
  } else {
    return decodeURIComponent(escape(atob(saveData)));
  }
}

// servers/home/exploits/save-file.ts
async function getObjectStore(store) {
  return new Promise((resolve, reject) => {
    const request = window.indexedDB.open("bitburnerSave", 1);
    request.onerror = () => {
      console.error("Error occurred when interacting with IndexDB. Result:", request.result);
      reject("Error occurred when interacting with IndexDB");
    };
    request.onsuccess = function() {
      const db = this.result;
      const objectStore = db.transaction([store], "readwrite").objectStore(store);
      resolve(objectStore);
    };
  });
}
async function getData(store, key) {
  const objectStore = await getObjectStore(store);
  return new Promise((resolve, reject) => {
    const request = objectStore.get(key);
    request.onerror = () => {
      console.error("Error occurred when getting data from IndexDB. Result:", request.result);
      reject("Error occurred when getting data from IndexDB");
    };
    request.onsuccess = () => {
      resolve(request.result);
    };
  });
}
async function putData(store, key, data) {
  const objectStore = await getObjectStore(store);
  return new Promise((resolve, reject) => {
    const request = objectStore.put(data, key);
    request.onerror = () => {
      console.error("Error occurred when putting data into IndexDB. Result:", request.result);
      reject("Error occurred when putting data into IndexDB");
    };
    request.onsuccess = () => {
      resolve(request.result);
    };
  });
}
async function main(ns) {
  const indexedDB = window.indexedDB;
  const dbs = await indexedDB.databases();
  for (const db of dbs) {
    ns.tprint(`DB: ${db.name}, ${db.version}`);
  }
  const objectStore = await getData("savestring", "save");
  const str = await decodeSaveData(objectStore);
  ns.write("save.txt", str);
  const jStr = JSON.parse(str);
  ns.tprint(JSON.stringify(Object.keys(jStr.data), null, 2));
  const pSave = JSON.parse(jStr.data.PlayerSave);
  ns.tprint(JSON.stringify(pSave.data.exploits, null, 2));
  if (pSave.data.exploits.includes("EditSaveFile")) {
    ns.tprint("Already have EditSaveFile exploit");
    return;
  }
  pSave.data.exploits.push("EditSaveFile");
  jStr.data.PlayerSave = JSON.stringify(pSave);
  const newStr = JSON.stringify(jStr);
  const newSave = await encodeJsonSaveString(newStr);
  await putData("savestring", "save", newSave);
}
export {
  main
};
